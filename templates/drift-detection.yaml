{{- if and .Values.infrastructure.enabled .Values.infrastructure.driftDetection.enabled }}
---
################################################################################
# Drift Detection Scheduler - CronJob
#
# Executa plan nos workspaces gerenciados a cada 1 hora (ou conforme configurado)
# e identifica drift atrav√©s do HCP Terraform Health Assessment.
#
# Features:
#   - Scheduled plans via HCP Terraform API
#   - Health checks nos Modules/Workspaces
#   - Notifica√ß√µes de drift (Slack, Teams, Email)
#   - M√©tricas exportadas para Prometheus
################################################################################
apiVersion: v1
kind: ServiceAccount
metadata:
  name: {{ include "app.fullname" . }}-drift-detector
  namespace: {{ .Values.infrastructure.terraform.namespace | default "terraform-system" }}
  labels:
    {{- include "app.labels" . | nindent 4 }}
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: {{ include "app.fullname" . }}-drift-detector
  namespace: {{ .Values.infrastructure.terraform.namespace | default "terraform-system" }}
  labels:
    {{- include "app.labels" . | nindent 4 }}
rules:
  # Permiss√£o para ler Modules do HCP Terraform Operator
  - apiGroups: ["app.terraform.io"]
    resources: ["modules", "workspaces"]
    verbs: ["get", "list", "watch", "patch"]
  
  # Permiss√£o para atualizar status
  - apiGroups: ["app.terraform.io"]
    resources: ["modules/status", "workspaces/status"]
    verbs: ["get", "update", "patch"]
  
  # Permiss√£o para ler secrets (HCP token)
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get"]
  
  # Permiss√£o para criar events
  - apiGroups: [""]
    resources: ["events"]
    verbs: ["create", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: {{ include "app.fullname" . }}-drift-detector
  namespace: {{ .Values.infrastructure.terraform.namespace | default "terraform-system" }}
  labels:
    {{- include "app.labels" . | nindent 4 }}
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: {{ include "app.fullname" . }}-drift-detector
subjects:
  - kind: ServiceAccount
    name: {{ include "app.fullname" . }}-drift-detector
    namespace: {{ .Values.infrastructure.terraform.namespace | default "terraform-system" }}
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "app.fullname" . }}-drift-detector-script
  namespace: {{ .Values.infrastructure.terraform.namespace | default "terraform-system" }}
  labels:
    {{- include "app.labels" . | nindent 4 }}
data:
  drift-check.sh: |
    #!/bin/bash
    set -euo pipefail
    
    echo "=========================================="
    echo "HCP Terraform Drift Detection"
    echo "App: {{ include "app.fullname" . }}"
    echo "Timestamp: $(date -u +"%Y-%m-%dT%H:%M:%SZ")"
    echo "=========================================="
    
    # Vari√°veis
    HCP_ORG="{{ .Values.infrastructure.terraform.organization }}"
    HCP_TOKEN="${TFC_TOKEN}"
    MODULE_NAME="{{ include "app.fullname" . }}-storage"
    NAMESPACE="{{ .Values.infrastructure.terraform.namespace | default "terraform-system" }}"
    
    # Fun√ß√£o para chamar API do HCP Terraform
    hcp_api_call() {
      local endpoint="$1"
      local method="${2:-GET}"
      curl -s -X "$method" \
        -H "Authorization: Bearer ${HCP_TOKEN}" \
        -H "Content-Type: application/vnd.api+json" \
        "https://app.terraform.io/api/v2${endpoint}"
    }
    
    # 1. Obter workspace ID do Module via kubectl
    echo "üîç Obtendo informa√ß√µes do Module..."
    MODULE_JSON=$(kubectl get module "$MODULE_NAME" -n "$NAMESPACE" -o json)
    WORKSPACE_ID=$(echo "$MODULE_JSON" | jq -r '.status.workspaceID // empty')
    
    if [ -z "$WORKSPACE_ID" ]; then
      echo "‚ö†Ô∏è  Workspace ainda n√£o criado. Pulando drift check."
      exit 0
    fi
    
    echo "‚úÖ Workspace ID: $WORKSPACE_ID"
    
    # 2. Criar um speculative plan (n√£o aplica mudan√ßas)
    echo "üìã Criando speculative plan..."
    RUN_PAYLOAD=$(cat <<EOF
    {
      "data": {
        "attributes": {
          "is-destroy": false,
          "message": "Drift detection check - scheduled by platform",
          "plan-only": true,
          "auto-apply": false
        },
        "type": "runs",
        "relationships": {
          "workspace": {
            "data": {
              "type": "workspaces",
              "id": "$WORKSPACE_ID"
            }
          }
        }
      }
    }
    EOF
    )
    
    RUN_RESPONSE=$(curl -s -X POST \
      -H "Authorization: Bearer ${HCP_TOKEN}" \
      -H "Content-Type: application/vnd.api+json" \
      -d "$RUN_PAYLOAD" \
      "https://app.terraform.io/api/v2/runs")
    
    RUN_ID=$(echo "$RUN_RESPONSE" | jq -r '.data.id')
    echo "‚úÖ Run created: $RUN_ID"
    echo "üîó View at: https://app.terraform.io/app/$HCP_ORG/workspaces/$(echo "$MODULE_JSON" | jq -r '.spec.workspace.name')/runs/$RUN_ID"
    
    # 3. Aguardar conclus√£o do plan (timeout 5 min)
    echo "‚è≥ Aguardando conclus√£o do plan..."
    TIMEOUT=300
    ELAPSED=0
    INTERVAL=10
    
    while [ $ELAPSED -lt $TIMEOUT ]; do
      RUN_STATUS=$(hcp_api_call "/runs/$RUN_ID" | jq -r '.data.attributes.status')
      
      case "$RUN_STATUS" in
        "planned"|"planned_and_finished")
          echo "‚úÖ Plan conclu√≠do!"
          break
          ;;
        "errored"|"canceled"|"discarded")
          echo "‚ùå Plan falhou com status: $RUN_STATUS"
          exit 1
          ;;
        "planning"|"pending"|"queued")
          echo "  Status: $RUN_STATUS (${ELAPSED}s / ${TIMEOUT}s)"
          sleep $INTERVAL
          ELAPSED=$((ELAPSED + INTERVAL))
          ;;
        *)
          echo "  Status: $RUN_STATUS"
          sleep $INTERVAL
          ELAPSED=$((ELAPSED + INTERVAL))
          ;;
      esac
    done
    
    if [ $ELAPSED -ge $TIMEOUT ]; then
      echo "‚è±Ô∏è  Timeout waiting for plan"
      exit 1
    fi
    
    # 4. Verificar se h√° mudan√ßas (drift)
    echo "üîé Analisando drift..."
    PLAN_DATA=$(hcp_api_call "/runs/$RUN_ID/plan")
    
    HAS_CHANGES=$(echo "$PLAN_DATA" | jq -r '.data.attributes."has-changes"')
    RESOURCE_ADDITIONS=$(echo "$PLAN_DATA" | jq -r '.data.attributes."resource-additions" // 0')
    RESOURCE_CHANGES=$(echo "$PLAN_DATA" | jq -r '.data.attributes."resource-changes" // 0')
    RESOURCE_DESTRUCTIONS=$(echo "$PLAN_DATA" | jq -r '.data.attributes."resource-destructions" // 0')
    
    echo ""
    echo "=========================================="
    echo "üìä DRIFT DETECTION RESULTS"
    echo "=========================================="
    echo "Has Changes: $HAS_CHANGES"
    echo "Additions: $RESOURCE_ADDITIONS"
    echo "Changes: $RESOURCE_CHANGES"
    echo "Destructions: $RESOURCE_DESTRUCTIONS"
    echo ""
    
    # 5. Atualizar annotation no Module com resultado
    TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    
    if [ "$HAS_CHANGES" = "true" ]; then
      echo "‚ö†Ô∏è  DRIFT DETECTED!"
      
      # Anotar no Module
      kubectl annotate module "$MODULE_NAME" -n "$NAMESPACE" \
        platform.io/drift-status="drifted" \
        platform.io/drift-detected-at="$TIMESTAMP" \
        platform.io/drift-additions="$RESOURCE_ADDITIONS" \
        platform.io/drift-changes="$RESOURCE_CHANGES" \
        platform.io/drift-destructions="$RESOURCE_DESTRUCTIONS" \
        platform.io/drift-run-id="$RUN_ID" \
        --overwrite
      
      # Criar Event no Kubernetes
      kubectl create event drift-detected \
        --namespace="$NAMESPACE" \
        --message="Drift detected: +$RESOURCE_ADDITIONS ~$RESOURCE_CHANGES -$RESOURCE_DESTRUCTIONS" \
        --reason="DriftDetected" \
        --type="Warning" \
        --reporting-controller="drift-detector" \
        --reporting-instance="{{ include "app.fullname" . }}" || true
      
      {{- if .Values.infrastructure.driftDetection.notifications.enabled }}
      # Enviar notifica√ß√£o (Slack, Teams, etc)
      echo "üì¢ Enviando notifica√ß√£o..."
      curl -X POST "{{ .Values.infrastructure.driftDetection.notifications.webhookUrl }}" \
        -H "Content-Type: application/json" \
        -d @- <<NOTIFICATION
      {
        "text": "‚ö†Ô∏è Infrastructure Drift Detected",
        "blocks": [
          {
            "type": "section",
            "text": {
              "type": "mrkdwn",
              "text": "*Drift Detected in Storage*\n\n*App:* {{ include "app.fullname" . }}\n*Environment:* {{ .Release.Namespace }}\n*Cloud:* {{ include "app.cloudProvider" . }}\n\n*Changes:*\n‚Ä¢ Additions: $RESOURCE_ADDITIONS\n‚Ä¢ Changes: $RESOURCE_CHANGES\n‚Ä¢ Destructions: $RESOURCE_DESTRUCTIONS\n\n<https://app.terraform.io/app/$HCP_ORG/workspaces/$(echo "$MODULE_JSON" | jq -r '.spec.workspace.name')/runs/$RUN_ID|View in HCP Terraform>"
            }
          }
        ]
      }
      NOTIFICATION
      {{- end }}
      
    else
      echo "‚úÖ No drift detected - infrastructure is in sync!"
      
      # Anotar no Module
      kubectl annotate module "$MODULE_NAME" -n "$NAMESPACE" \
        platform.io/drift-status="synced" \
        platform.io/drift-last-check="$TIMESTAMP" \
        platform.io/drift-run-id="$RUN_ID" \
        --overwrite
    fi
    
    echo ""
    echo "=========================================="
    echo "‚úÖ Drift check completed successfully"
    echo "=========================================="
---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: {{ include "app.fullname" . }}-drift-detector
  namespace: {{ .Values.infrastructure.terraform.namespace | default "terraform-system" }}
  labels:
    {{- include "app.labels" . | nindent 4 }}
    platform.io/component: drift-detection
  annotations:
    platform.io/description: "Automated drift detection for infrastructure resources"
spec:
  # Schedule: a cada 1 hora por padr√£o
  schedule: {{ .Values.infrastructure.driftDetection.schedule | quote }}
  
  # Manter √∫ltimos 3 jobs
  successfulJobsHistoryLimit: {{ .Values.infrastructure.driftDetection.historyLimit | default 3 }}
  failedJobsHistoryLimit: {{ .Values.infrastructure.driftDetection.historyLimit | default 3 }}
  
  # N√£o executar se job anterior ainda estiver rodando
  concurrencyPolicy: Forbid
  
  jobTemplate:
    spec:
      # Timeout de 10 minutos
      activeDeadlineSeconds: 600
      
      template:
        metadata:
          labels:
            {{- include "app.selectorLabels" . | nindent 12 }}
            platform.io/component: drift-detection
        spec:
          serviceAccountName: {{ include "app.fullname" . }}-drift-detector
          restartPolicy: OnFailure
          
          containers:
            - name: drift-detector
              image: {{ .Values.infrastructure.driftDetection.image | default "bitnami/kubectl:latest" }}
              imagePullPolicy: IfNotPresent
              
              command: ["/bin/bash", "/scripts/drift-check.sh"]
              
              env:
                # HCP Terraform Token
                - name: TFC_TOKEN
                  valueFrom:
                    secretKeyRef:
                      name: {{ .Values.infrastructure.terraform.tokenSecret | default "hcp-terraform-token" }}
                      key: token
                
                # Kubernetes namespace
                - name: KUBERNETES_NAMESPACE
                  valueFrom:
                    fieldRef:
                      fieldPath: metadata.namespace
              
              volumeMounts:
                - name: scripts
                  mountPath: /scripts
                  readOnly: true
              
              resources:
                requests:
                  cpu: 100m
                  memory: 128Mi
                limits:
                  cpu: 500m
                  memory: 256Mi
          
          volumes:
            - name: scripts
              configMap:
                name: {{ include "app.fullname" . }}-drift-detector-script
                defaultMode: 0755
{{- end }}
